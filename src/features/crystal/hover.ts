/**
 * CRYSTAL23 hover documentation
 */

import { Hover, Position, MarkupKind } from 'vscode-languageserver-types';
import { TextDocument } from 'vscode-languageserver-textdocument';
import { CrystalDocument, getTokenAtPosition } from './parsing';
import { CRYSTAL_TAGS } from '../../data/crystal-tags';

/**
 * Get hover information for a position in a CRYSTAL23 document.
 *
 * @param document - LSP text document for a CRYSTAL file.
 * @param parsed - Parsed CRYSTAL document.
 * @param position - Hover position.
 * @returns Hover payload with keyword documentation or null.
 */
export function getCrystalHover(document: TextDocument, parsed: CrystalDocument, position: Position): Hover | null {
    void document;

    const token = getTokenAtPosition(parsed, position);
    if (!token) return null;

    // Handle keywords
    if (token.type === 'keyword' || token.type === 'block-start' || token.type === 'geometry-type') {
        const keyword = token.text.toUpperCase();
        const def = CRYSTAL_TAGS[keyword];

        if (def) {
            return {
                contents: {
                    kind: MarkupKind.Markdown,
                    value: formatHoverContent(keyword, def)
                },
                range: token.range
            };
        }

        // Try geometry types
        if (token.type === 'geometry-type') {
            return {
                contents: {
                    kind: MarkupKind.Markdown,
                    value: getGeometryTypeDescription(keyword)
                },
                range: token.range
            };
        }
    }

    // Handle END keywords
    if (token.type === 'end') {
        return {
            contents: {
                kind: MarkupKind.Markdown,
                value: '**END**\n\nTerminates a section or block in the CRYSTAL23 input.'
            },
            range: token.range
        };
    }

    return null;
}

function formatHoverContent(
    keyword: string,
    def: {
        description?: string;
        category?: string;
        type?: string;
        argCount?: number | [number, number];
        argTypes?: string[];
        defaultValue?: unknown;
        seeAlso?: string[];
    }
): string {
    const lines: string[] = [];

    lines.push(`## ${keyword}`);
    lines.push('');

    if (def.description) {
        lines.push(def.description);
        lines.push('');
    }

    // Metadata table
    const metadata: string[] = [];
    if (def.category) metadata.push(`**Category:** ${def.category}`);
    if (def.type) metadata.push(`**Type:** ${def.type}`);

    if (def.argCount !== undefined) {
        const count = Array.isArray(def.argCount) ? `${def.argCount[0]}-${def.argCount[1]}` : String(def.argCount);
        metadata.push(`**Arguments:** ${count}`);
    }

    if (def.argTypes && def.argTypes.length > 0) {
        metadata.push(`**Argument types:** \`${def.argTypes.join(', ')}\``);
    }

    if (def.defaultValue !== undefined) {
        metadata.push(`**Default:** \`${def.defaultValue}\``);
    }

    if (metadata.length > 0) {
        lines.push(metadata.join(' | '));
        lines.push('');
    }

    if (def.seeAlso && def.seeAlso.length > 0) {
        lines.push(`---`);
        lines.push(`*See also:* ${def.seeAlso.join(', ')}`);
    }

    return lines.join('\n');
}

function getGeometryTypeDescription(type: string): string {
    const descriptions: Record<string, string> = {
        CRYSTAL: `## CRYSTAL

3D periodic system with full crystalline symmetry.

**Usage:**
\`\`\`
CRYSTAL
<space group number>
<cell parameters>
<number of atoms in asymmetric unit>
<atomic positions>
\`\`\`

Space groups range from 1 to 230.`,

        SLAB: `## SLAB

2D periodic system (surface/thin film).

**Usage:**
\`\`\`
SLAB
<layer group number>
<2D cell parameters: a, b, gamma>
<number of atoms in asymmetric unit>
<atomic positions>
\`\`\`

Layer groups range from 1 to 80.`,

        POLYMER: `## POLYMER

1D periodic system (chain/wire).

**Usage:**
\`\`\`
POLYMER
<rod group number>
<lattice parameter a>
<number of atoms in asymmetric unit>
<atomic positions>
\`\`\``,

        MOLECULE: `## MOLECULE

Non-periodic molecular system.

**Usage:**
\`\`\`
MOLECULE
<number of atoms>
<atomic positions in Cartesian coordinates>
\`\`\`

Note: No symmetry operations applied. Use molecular point groups if needed.`,

        HELIX: `## HELIX

Helical system (e.g., nanotubes, DNA).

**Usage:**
\`\`\`
HELIX
<helix parameters>
<atoms>
\`\`\``,

        EXTERNAL: `## EXTERNAL

Read geometry from external file (fort.34 / .gui).

**Usage:**
\`\`\`
EXTERNAL
\`\`\`

The geometry is read from a separate file in CRYSTAL's GUI format.
Useful for complex structures or geometries generated by other tools.`
    };

    return descriptions[type] || `## ${type}\n\nGeometry type for CRYSTAL23 calculation.`;
}
